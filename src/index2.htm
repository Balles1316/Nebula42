<!doctype html>
<html lang="es">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Nebula42</title>
    <style>
        /* Reset */
        html,body{height:100%;margin:0;background:#6ec1ff;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial}
        #game{display:block;margin:24px auto;border:8px solid #2b2b2b;background:linear-gradient(#6ec1ff,#7fd0ff);box-shadow:0 8px 30px rgba(0,0,0,.15);}
        .info{width:800px;margin:12px auto;text-align:center;color:#111}
        .kbd{display:inline-block;padding:4px 8px;border-radius:6px;background:#fff7;border:1px solid #ddd;margin:0 4px}
        /* small mobile-friendly canvas */
        @media (max-width:820px){#game{width:100%;height:360px;}}</style>
</head>
<body>
<div class="info">
    <h2>Nebula42</h2>
    <br>
</div>
<canvas id="game" width="800" height="440"></canvas>
<div class="info" style="font-size:0.9rem">Controles: <span class="kbd">←</span> <span class="kbd">→</span> mover — <span class="kbd">Espacio</span> o <span class="kbd">↑</span> saltar. Recolecta monedas y evita enemigos.</div>

<script>
    /* -------------------------------
       Mini platformer: HTML5 canvas
       - Player (rect) moves, jumps
       - Simple tile map platforms
       - Coins and a walking enemy
       - Camera follows player
       - No copyrighted Nintendo assets used
       -------------------------------*/

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;

    // Game state
    let keys = {};
    let cameraX = 0;
    let score = 0;
    let gameOver = false;

    // Level: 0 = empty, 1 = ground tile, 2 = coin, 3 = enemy spawn
    const level = [];
    const TILE = 40; // tile size
    const LEVEL_W = 200; // number of tiles wide (simple long level)
    const LEVEL_H = Math.floor(H / TILE);

    // build simple level (ground + some platforms and coins)
    for (let y=0;y<LEVEL_H;y++){
        level[y]=[];
        for (let x=0;x<LEVEL_W;x++){
            level[y][x]=0;
        }
    }
    // ground
    for (let x=0;x<LEVEL_W;x++){
        level[LEVEL_H-1][x]=1;
        if (Math.random()<0.02) level[LEVEL_H-2][x]=1; // occasional double-high
    }
    // platforms and coins
    for (let i=0;i<60;i++){
        const px = 5 + Math.floor(Math.random()*(LEVEL_W-10));
        const py = 4 + Math.floor(Math.random()*(LEVEL_H-6));
        const len = 2 + Math.floor(Math.random()*4);
        for (let j=0;j<len;j++) level[py][px+j]=1;
        if (Math.random()<0.8) level[py-1][px+Math.floor(Math.random()*len)]=2; // coin above
    }
    // enemies
    const enemies = [];
    for (let i=0;i<12;i++){
        const ex = 8 + Math.floor(Math.random()*(LEVEL_W-20));
        // find ground tile x,y
        for (let y=0;y<LEVEL_H-1;y++){
            if (level[y+1][ex]===1 && level[y][ex]===0){
                enemies.push({x:ex*TILE,y:y*TILE,w:36,h:36,dir: Math.random()<0.5? -1:1,spd:0.7});
                break;
            }
        }
    }

    // Player
    const player = {
        x: TILE*2,
        y: (LEVEL_H-2)*TILE - 36,
        w:36,
        h:36,
        vx:0,
        vy:0,
        speed:2.8,
        jumpPower:10,
        onGround:false
    };

    // handy utilities
    function tileAtPixel(px,py){
        const tx = Math.floor(px / TILE);
        const ty = Math.floor(py / TILE);
        if (tx<0||tx>=LEVEL_W||ty<0||ty>=LEVEL_H) return 0;
        return level[ty][tx];
    }

    // input
    window.addEventListener('keydown',e=>{ keys[e.code]=true; if(['ArrowUp','Space','KeyW'].includes(e.code)) e.preventDefault(); });
    window.addEventListener('keyup',e=>{ keys[e.code]=false; });

    function update(dt){
        if (gameOver) return;
        // horizontal control
        const left = keys['ArrowLeft']||keys['KeyA'];
        const right = keys['ArrowRight']||keys['KeyD'];
        let accel = 0;
        if (left) accel = -player.speed;
        if (right) accel = player.speed;
        player.vx = accel;

        // apply horizontal
        player.x += player.vx;
        // horizontal collision with tiles
        if (player.vx !== 0){
            const dir = player.vx>0?1:-1;
            const probeX = dir>0 ? player.x+player.w : player.x;
            // check top and bottom points
            for (let py of [player.y+2, player.y+player.h-2]){
                if (tileAtPixel(probeX, py)===1){
                    // snap to tile edge
                    const tx = Math.floor(probeX/TILE);
                    if (dir>0) player.x = tx*TILE - player.w - 0.01; else player.x = (tx+1)*TILE + 0.01;
                    player.vx = 0;
                }
            }
        }

        // gravity
        player.vy += 0.5; // gravity
        if (player.vy>12) player.vy=12;
        player.y += player.vy;

        // vertical collision
        player.onGround = false;
        // check below and above
        const points = [player.x+2, player.x+player.w-2];
        for (let px of points){
            // below
            if (tileAtPixel(px, player.y + player.h)===1){
                const ty = Math.floor((player.y+player.h)/TILE);
                player.y = ty*TILE - player.h - 0.01;
                player.vy = 0;
                player.onGround = true;
            }
            // above
            if (tileAtPixel(px, player.y)===1){
                const ty = Math.floor(player.y/TILE);
                player.y = (ty+1)*TILE + 0.01;
                player.vy = 0.01;
            }
        }

        // jump
        if ((keys['Space']||keys['ArrowUp']||keys['KeyW']) && player.onGround){
            player.vy = -player.jumpPower;
            player.onGround = false;
        }

        // collect coins
        const cx = Math.floor((player.x+player.w/2)/TILE);
        const cy = Math.floor((player.y+player.h/2)/TILE);
        if (level[cy] && level[cy][cx]===2){ level[cy][cx]=0; score+=10; }

        // enemies: simple patrol and collision
        for (let e of enemies){
            // gravity for enemy
            e.vy = e.vy ? e.vy + 0.5 : 0.5;
            if (e.vy>12) e.vy=12;
            e.y += e.vy;
            // land on ground
            if (tileAtPixel(e.x+e.w/2, e.y+e.h)===1){
                const ty = Math.floor((e.y+e.h)/TILE);
                e.y = ty*TILE - e.h - 0.01; e.vy = 0;
            }
            // move horizontally
            e.x += e.dir * e.spd;
            // flip when about to walk off a tile or hit wall
            const frontX = e.dir>0 ? e.x+e.w+4 : e.x-4;
            const underFront = tileAtPixel(frontX, e.y+e.h+6);
            const frontHit = tileAtPixel(frontX, e.y+8);
            if (underFront!==1 || frontHit===1) e.dir*=-1;
        }

        // collisions player <-> enemy
        for (let i=enemies.length-1;i>=0;i--){
            const e = enemies[i];
            if (rectsOverlap(player,e)){
                // if player is falling onto enemy -> stomp
                if (player.vy>1){ enemies.splice(i,1); player.vy = -6; score+=50; }
                else { gameOver = true; }
            }
        }

        // camera
        cameraX = player.x - 200;
        if (cameraX<0) cameraX=0;
        if (cameraX > LEVEL_W*TILE - W) cameraX = LEVEL_W*TILE - W;
    }

    function rectsOverlap(a,b){
        return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
    }

    function draw(){
        // background
        ctx.clearRect(0,0,W,H);
        // sky gradient
        const g = ctx.createLinearGradient(0,0,0,H);
        g.addColorStop(0,'#9be7ff'); g.addColorStop(1,'#7fd0ff');
        ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

        ctx.save();
        ctx.translate(-cameraX,0);

        // draw tiles
        for (let y=0;y<LEVEL_H;y++){
            for (let x=0;x<LEVEL_W;x++){
                const t = level[y][x];
                if (t===1){
                    // ground tile
                    ctx.fillStyle = '#7b4f1d';
                    ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
                    ctx.fillStyle = '#a56d39'; ctx.fillRect(x*TILE, y*TILE+TILE-8, TILE, 8);
                } else if (t===2){
                    // coin
                    const cx = x*TILE + TILE/2, cy = y*TILE + TILE/2;
                    ctx.beginPath(); ctx.ellipse(cx,cy,10,12,0,0,Math.PI*2); ctx.fillStyle='#ffd24a'; ctx.fill();
                    ctx.strokeStyle='#b88916'; ctx.stroke();
                }
            }
        }

        // draw enemies
        for (let e of enemies){
            ctx.fillStyle='#c33'; ctx.fillRect(e.x, e.y, e.w, e.h);
            ctx.fillStyle='rgba(0,0,0,0.12)'; ctx.fillRect(e.x+4, e.y+e.h-6, e.w-8,4);
        }

        // draw player (simple hero)
        ctx.fillStyle = '#ff4d4d';
        ctx.fillRect(player.x, player.y, player.w, player.h);
        // eyes
        ctx.fillStyle='#fff'; ctx.fillRect(player.x+8, player.y+10,6,6); ctx.fillRect(player.x+22, player.y+10,6,6);
        ctx.fillStyle='#000'; ctx.fillRect(player.x+10, player.y+12,2,2); ctx.fillRect(player.x+24, player.y+12,2,2);

        // HUD
        ctx.restore();
        ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(12,12,180,36);
        ctx.fillStyle='#fff'; ctx.font='18px Arial'; ctx.fillText('Puntos: '+score,20,36);
        if (gameOver){ ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(W/2-150,H/2-40,300,90); ctx.fillStyle='#fff'; ctx.textAlign='center'; ctx.font='28px Arial'; ctx.fillText('GAME OVER',W/2,H/2-4); ctx.font='16px Arial'; ctx.fillText('Refresca para jugar de nuevo',W/2,H/2+26); ctx.textAlign='left'; }
    }

    let last=0;
    function loop(ts){
        const dt = (ts-last)/16.666; last=ts;
        update(dt);
        draw();
        requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // small helpers for replacing level or resetting
    function resetGame(){
        // simple reload
        window.location.reload();
    }

</script>
</body>
</html>
